% TO DO: Inserire plot che mostra sensori rispetto a FOV

clc; clear
path_to_rec_toolbox = 'E:\Scardigno\Fotoacustica-MB\mb-rec-msot';
run([path_to_rec_toolbox filesep 'startup_reconstruction.m']);

%% Define model
params.device_probe_id = 'TEST_Device_Linear'; %'PoliTo_probe'; % see Probe.m for all available probes
params.max_imgs = 1;
% params.VOC_id_imgs = {"2009_004734.jpg", "2007_002216.jpg" "2007_000123.jpg" "2007_001761.jpg" "2007_002953.jpg" "2007_003104.jpg" "2007_003367.jpg" "2007_004510.jpg" "2007_005360.jpg"};
params.VOC_id_imgs = 256;
params.use_eir = true;
params.use_indiv_eir = false;
params.use_sir = false;
params.use_single_speed_of_sound = true;
params.num_cropped_samples_at_sinogram_start = 0;
params.filt_cutoff_min = 1e5;
params.filt_cutoff_max = 12e6;
params.field_of_view = [-0.02 0.02 -0.02 0.02]; %[-0.01905 0.01905 -0.0192 0.0192]; % [x_fov_min x_fov_max z_fov_min z_fov_max]
params.number_of_grid_points_fov = [256 256];            % [grid_points_x_dimension grid_points_z_dimension]
params.speed_of_sound_tissue = 1500;
params.model_normalization_factor = [];                  % if empty, the model is normalized so that its largest singular values is 1.
params.broken_transducers = [];
%%%%%%%% REGULARIZATION Methods %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NN_REC_WITHOUT_REG        -> Non-negative reconstruction without regularization
% L2_TIKHONOV_AND_LAPLACIAN -> Non-negative reconstruction with L2 and L2 Laplace regularization
% L1_SHEARLET               -> Shearlet non-negative limited view reconstruction
% TV_NN_REG                 -> TV non-negative limited view reconstruction
% L1_EYE_REG                -> Non-negative reconstruction with L1 eye reg. matrix
params.regularization = '';
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
params.lambda_shearlet = 1e-4; %1e-2 su set_parameters_for_data_generation.m di deepMB  % Strength of Shearlet L1 regularization, only used if regularization = 'L1_SHEARLET' 
params.lambda_tikhonov = 1e-4;                           % Strength of Tikhonov regularization, only used if regularization = 'L2_TIKHONOV_AND_LAPLACIAN' 
params.lambda_TV = 1e-3;
params.lambda_L1_eye_reg = 1e-4;
params.lambda_laplacian = 0;                             % Strength of L2 Laplacian regularization, only used if regularization = 'L2_TIKHONOV_AND_LAPLACIAN' 
params.num_iterations_mb = 100;
params_concave = load_params_concave(params);


model_linear = define_model_for_reconstruction(params.field_of_view, params.number_of_grid_points_fov, params.device_probe_id, params.use_eir, params.use_indiv_eir, params.use_sir, params.use_single_speed_of_sound, params.speed_of_sound_tissue, params.num_cropped_samples_at_sinogram_start, params.filt_cutoff_min, params.filt_cutoff_max, params.model_normalization_factor);
model_concave = define_model_for_reconstruction(params_concave.field_of_view, params_concave.number_of_grid_points_fov, 'TEST_Device_Curved', params_concave.use_eir, params_concave.use_indiv_eir, params_concave.use_sir, params_concave.use_single_speed_of_sound, params_concave.speed_of_sound_tissue, params_concave.num_cropped_samples_at_sinogram_start, params_concave.filt_cutoff_min, params_concave.filt_cutoff_max, params_concave.model_normalization_factor);

%% Execute reconstruction and calculate residuals
reg_methods = ["L1_SHEARLET"] %, "TV_NN_REG"];
lambdas = ["1e-3"];

results = struct();
for a = 1:numel(reg_methods)
    results.(reg_methods(a)) = table('Size', [size(lambdas, 2), 7], 'VariableTypes', ["string", "double", "double", "double", "double", "double", "double"], ...
                                  'VariableNames', ["Lambda", "lCurveErrImg", "lCurveErrReg", "MAE_mean", "MAE_std", "SSIM_mean", "SSIM_std"]);
end

for i = 1:numel(lambdas)
    
    params.lambda_shearlet = str2double(lambdas(i));
    params.lambda_TV = str2double(lambdas(i));

    if any(strcmp(lambdas(i) , ["1e-6", "1e-5", "1e-4", "1e-3", "1e-2"]))
        enable_metrics = true;
    else
        enable_metrics = false;
    end

    % Reconstruction
    %[recs, references, lCurveErrImg, lCurveErrReg] = reconstruct_from_VOC_residuals('VOC2012', model_linear, params, reg_methods, true);
    if enable_metrics
        recs_concave = reconstruct_from_VOC_residuals('VOC2012', model_concave, params_concave, reg_methods, false);
    end
    
    %% Compute residuals
    % Calculate the norm 2 squared
    % squared_norm_of_reference = zeros(1, size(references, 3));
    % for img = 1:size(references, 3)
    %     squared_norm_of_reference(img) = norm(references(:, :, img), 2)^2;
    % end

    recs_names = fieldnames(recs);
    for j = 1:size(recs_names, 1)
        recs_name = recs_names{j};
        % recs_values = getfield(recs, recs_name);
        % 
        % for img_rec = 1:size(recs_values, 3)
        %     norm_of_solution = norm(recs_values(:, :, img_rec), 2)^2;
        %     norm_of_estimation_minus_reference(img_rec) = norm(recs_values(:, :, img_rec) - references(:, :, img_rec), 2);
        % 
        %     % Calculate the data residual norm
        %     data_residual_norm(img_rec) = (norm_of_estimation_minus_reference(img_rec)^2) / squared_norm_of_reference(img_rec);
        % end
        % results.(recs_name)(i, :) = {lambdas(i), mean(norm_of_solution), mean(data_residual_norm)};
        % lCurveErrImg.(recs_name)
        if enable_metrics
            stats = struct();
            for metric_idx = 1:size(references, 3)
                SSIM_(metric_idx) = ssim(recs.(recs_name)(:, :, metric_idx), recs_concave.(recs_name)(:, :, metric_idx));
                MAE_(metric_idx) = calMAE(recs.(recs_name)(:, :, metric_idx), recs_concave.(recs_name)(:, :, metric_idx));
            end
            stats.SSIM_mean = mean(SSIM_);
            stats.SSIM_std = std(SSIM_);
            stats.MAE_mean = mean(MAE_);
            stats.MAE_std = std(MAE_);
        else
            stats.SSIM_mean = NaN;
            stats.SSIM_std = NaN;
            stats.MAE_mean = NaN;
            stats.MAE_std = NaN;
        end
        results.(recs_name)(i, :) = {lambdas(i), lCurveErrImg.(recs_name), lCurveErrReg.(recs_name), stats.SSIM_mean, stats.SSIM_std, stats.MAE_mean, stats.MAE_std};
        writetable(results.(recs_name),'L_CURVE.xls', 'WriteMode', 'overwritesheet', 'Sheet', j)

    end    
end


